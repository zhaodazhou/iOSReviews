# 包体积优化

在项目中，采用的优化方式有：  

1. 图片资源处理，包括删除无用图片，压缩大图片，图片资源放到服务端（比如banner），对图片进行裁剪显示（根据业务场景，传参数给服务端，传回裁剪或压缩后的图片回来）；
2. 删掉不在使用的库，比如扫码sdk，用系统的现有的库。

## 理论方面  

### 1. 包大小一般有3个方面，如下  

在上传前后我们有三个指标：  

- APP原始包体积：上传前 IPA 解包后，实际 APP 的大小
- 下载体积：AppStore 中流量下载时提示框的大小
- 安装体积：AppStore 中 APP 详情中显示的大小

### 2. 各个占比  

资源（图片、音视频、文稿、nib。zip等，50%左右）、二进制文件（25%左右）、framework

#### 2.1 资源清理  

对于资源的处理其实方式就是常规那么几种：
资源清理、资源整理、资源压缩、资源云端迁移、资源合并等等，总之就是想尽一切办法去降低资源所占用的本地空间。

#### 2.2 二进制文件  

无用代码检测

动态库依赖裁剪

编译优化
Asset Catalog Compiler Optimization
修改为space，则Asset编译优化可以降低Asset.car产物体积

EXPORTED_SYMBOLS_FILE
裁剪输出的符号，但用了firebase就不能用了，其需要crash相关的信息

Link-Time Optimization
LTO的优化主要体现在跨文件的废弃代码裁剪优化、永远不会执行的空逻辑优化、内联优化，意思是直接复制函数，减少内联层级，提升函数栈的执行效率和空间利用率。

另外经过测试验证了LTO只对静态语言生效，OC是动态语言，所有函数方法有可能在运行时被动态调用，所以是不可能裁剪的，这就是为什么在链接静态库时，如果是C库，那么看起来原来二进制很大，实际上被实际链接进来的只有真实使用的小部分，但是如果是OC库则基本上全部会链接。所以如果你的APP源码中C或者C++代码较多的话在此项上收益可能会大一些。

GCC_OPTIMIZATION_LEVEL
此项意通过更激进的GCC编译优化，进而产生更低的二进制产物，Xcode默认是Debug设置O0，Release设置为Os，但其实还可以使用Oz模式，从而达到更小的体积。
