# Weak 的内部实现原理

在Objective-C中，`weak` 引用是一种特殊的非拥有引用，用于避免循环引用和内存泄漏。`weak` 引用在其所指向的对象被销毁时会自动置为 `nil`，这使得 `weak` 引用非常适合于避免循环引用（如在委托模式中常用）。要理解 `weak` 的内部实现原理，需要了解Objective-C运行时机制和引用计数系统。以下是对 `weak` 引用的内部实现原理的详细解释：

### 1. **引用计数基础**

Objective-C 使用引用计数（referenced counting）来管理内存。每个对象都有一个引用计数（retain count），对象的生命周期通过引用计数来管理：

- **强引用**：增加引用计数。
- **释放（release）**：减少引用计数。
- 当引用计数为零时，对象会被销毁。

### 2. **弱引用定义**

`weak` 引用不会增加对象的引用计数。当一个对象销毁时，所有指向它的 `weak` 引用会自动被置为 `nil`，以防止悬挂指针（dangling pointer）。

### 3. **弱引用的实现细节**

`weak` 引用的实现依赖于一张全局的弱引用表（weak reference table），用于记录所有指向某个对象的弱引用。当对象销毁时，运行时系统会在这张表中查找所有指向该对象的 `weak` 引用，并将这些引用置为 `nil`。

#### 具体步骤如下

1. **弱引用存储**：当你创建一个 `weak` 引用时，运行时系统会将该弱引用地址和它所指向的对象地址映射并存储在弱引用表中。
2. **对象销毁检测**：当对象的引用计数降为零时，运行时系统会在对象销毁之前，查找弱引用表中所有指向它的弱引用。
3. **弱引用清理**：运行时系统将所有找到的弱引用地址置为 `nil`。
4. **对象销毁**：完成弱引用清理后，对象被销毁，释放相应的内存。

#### 插入弱引用表的具体步骤

1. **初始化弱引用**：当你创建一个 `weak` 引用时，执行一个 `objc_storeWeak` 函数，该函数会将 `weak` 引用地址和对象地址插入到全局的弱引用表中。
2. **设置弱引用表**：弱引用表借助哈希表实现，键为对象地址，值为指向该对象的所有 `weak` 引用地址的集合。

### 4. **示例代码与运行时实现**

#### 弱引用示例

```objective-c
__weak MyClass *weakObject = strongObject;
```

#### 运行时初步实现

假设 `strongObject` 的地址是 `0x1000`，`weakObject` 的地址是 `0x2000`。当你创建 `weakObject` 时：

```c
objc_storeWeak(&weakObject, strongObject);
```

在 `objc_storeWeak` 中：

1. 检查 `strongObject` 是否为 `nil`，如果是，直接将 `weakObject` 置为 `nil`。
2. 查找全局弱引用表中是否已经存在以 `strongObject` 为键的条目。如果存在，将 `weakObject` 的地址添加到该条目的值集合中；如果不存在，创建一个新条目，以 `strongObject` 地址为键，值为包含 `weakObject` 地址的集合。

#### 对象销毁时的处理

假设 `strongObject` 的引用计数降为零，进入销毁流程：

1. 运行时会调用 `objc_release` 或类似函数。
2. 在销毁对象之前，运行时系统会通过全局弱引用表查找所有指向 `strongObject` 的 `weak` 引用地址。
3. 遍历这些 `weak` 引用地址，并将它们设置为 `nil`。
4. 最后，销毁对象并释放内存。

### 5. **性能与开销**

虽然弱引用表的管理增加了一定的开销，但它确保了安全性和内存管理的有效性。Objective-C 运行时系统使用高效的数据结构（如哈希表）来存储和查找弱引用，以尽量减小性能影响。

### 6. **线程安全**

Objective-C 运行时系统还针对弱引用表的更新操作进行了同步处理，以确保在多线程环境下的线程安全性。操作如插入、删除和查找均是线程安全的。

### 总结

`weak` 引用在Objective-C中提供了一种安全的内存管理机制，通过全局弱引用表的管理，实现了对象销毁时自动清理弱引用，有效避免了循环引用和悬挂指针。理解 `weak` 引用的内部实现原理有助于开发者编写更安全和高效的代码，并合理地运用内存管理策略。
