# 锁

锁的思维导图如下：![思维导图](./lock.png '锁的思维导图')

## mutex（互斥量）

mutex（mutual exclusive）即互斥量（互斥体）。也便是常说的互斥锁。
尽管名称不含lock，但是称之为锁，也是没有太大问题的。mutex无疑是最常见的多线程同步方式。其思想简单粗暴，多线程共享一个互斥量，然后线程之间去竞争。得到锁的线程可以进入临界区执行代码。

mutex是睡眠等待（sleep waiting）类型的锁，当线程抢互斥锁失败的时候，线程会陷入休眠。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。

此外，依据同一线程是否能多次加锁，把互斥量又分为如下两类：

- 是：称为『递归互斥量』recursive mutex ，也称『可重入锁』reentrant lock
- 否：即『非递归互斥量』non-recursive mute），也称『不可重入锁』non-reentrant mutex

若同一线程对非递归的互斥量多次加锁，可能会造成死锁。递归互斥量则无此风险。

## spinlock（自旋锁）

什么是自旋（spin）呢？更为通俗的一个词是『忙等待』（busy waiting）。最最通俗的一个理解，其实就是死循环……。

单看使用方法和使用互斥量的代码是差不多的。只不过自旋锁不会引起线程休眠。当共享资源的状态不满足的时候，自旋锁会不停地循环检测状态。因为不会陷入休眠，而是忙等待的方式也就不需要条件变量。
这是优点也是缺点。不休眠就不会引起上下文切换，但是会比较浪费CPU。

## condition variable（条件变量）

请注意条件变量不是锁，它是一种线程间的通讯机制，并且几乎总是和互斥量一起使用的。所以互斥量和条件变量二者一般是成套出现的。比如C++11中也有条件变量的API： std::condition_variable。

## read-write lock（读写锁）

顾名思义『读写锁』就是对于临界区区分读和写。在读多写少的场景下，不加区分的使用互斥量显然是有点浪费的。此时便该上演读写锁的拿手好戏。

读写锁的含义是准确的：是一种 读共享，写独占的锁。

读写锁的特性：
当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会阻塞（不是失败）。
当读写锁被加了读锁时，其他线程对该锁加写锁会阻塞，加读锁会成功。

其实加读锁和加写锁这两个说法可能会造成误导，让人误以为是有两把锁，其实读写锁是一个锁。所谓加读锁和加写锁，准确的说法可能是『给读写锁加读模式的锁定和加写模式的锁定』。
读写锁和互斥量一样也有trylock函数，也是以非阻塞地形式来请求锁，不会导致阻塞。

## dispatch_semaphore 信号量

## 乐观锁

乐观锁假设数据一般不会冲突，所以在访问数据的时候不加锁。只有在提交更新时才会检查是否有其他线程修改了数据。如果发现冲突，则重试或者报错。这种方式认为大部分操作不会发生冲突，可以提升并发性能。

特点

- 无锁机制：读取数据时不加锁，提交更新时检查版本号或其他校验机制。
- 适用场景：适用于读操作远多于写操作的场景，这样可以减少锁开销，提高并发性能。
- 冲突检测：通过版本号或时间戳等机制来检测是否发生冲突，从而决定是否需要重试。
- 例子：很多ORM框架（例如Hibernate）中提供的版本号控制机制就是一种乐观锁的实现。

## 悲观锁

悲观锁假设会有数据竞争，因此在访问数据之前，会先锁定资源，防止其他线程访问。这种方式时刻保持警惕，认为大部分操作会发生冲突，所以每次都加锁。

特点

- 加锁机制：每次操作数据时都要先获取锁，操作完成后释放锁。
- 适用场景：适用于写操作非常频繁的场景，因为在这种情况下，加锁可以有效防止数据竞争。
- 并发性低：由于每次操作都要获取锁，可能会造成较大的性能开销，特别是在锁冲突较高的情况下。
- 例子：数据库中的行锁、表锁都是悲观锁的例子。
