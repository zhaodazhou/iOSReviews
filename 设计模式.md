# 设计模式

## 模式归类

- 创建型模式：将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦
- 行为型模式：涉及到类与对象如何交互及分配职责
- 结构型模式：把类或对象组合到更大的结构中

## 策略模式

实现一批算法簇（这些算法都是实现某个特定的接口协议），在实际使用时，可以这些算法可以相互替换（因为其属于所实现的协议类型属性）。

## 命令模式

目标是将“请求”的调用者与请求的执行者解耦。

具体是：将“请求”封装成对象，以便使用不同的请求来参数化其他对象。然后调用对象实现的接口execute()方法，方法中的“请求对象”再去执行相应的具体实现。

例如：

iOS上的addTarget方法。将用户点按button的这个动作请求，传递给参数对象target，让其selector来执行。而用户根本不需要知道这个target是谁，以及其是如何执行的。

再例如：

客户在餐厅点餐，只需要报出菜名后，由服务员把菜单交给后厨，后厨自动会根据菜名来做，做完后直接端给客户。这其中就是把请求者（客户）的请求（菜），传达给请求的执行者（后厨）来实现的。

## 模板方法模式

对算法进行封装。

在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中去实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

比如画K线，大部分股票类型都有共同的部分，但A股与美股，或者债券类的走势可能有些差异，这就可以通过这个模式来实现，毕竟总体的画法是步骤是一样的，就在于一些细节方面如何处理，这一点完全可以交给子类去实现。其中还可以通过钩子的挂载与否，改变这个算法的步骤。

又比如，冲咖啡与泡茶，都需要烧水、放茶叶（咖啡）、倒水、加糖（奶）等步骤，这四个步骤就可以理解为一个算法，可以抽象成一个模板方法模式。

## 工厂模式

简单工厂，通过静态方法实现多种类型对象的初始化。这样将创建的动作统一到一个方法中，便于维护，虽然简单，但实用。

简单工厂是由一个具体类或对象负责所有具体类的实例化，而工厂方法模式将类的实例化下放到子类中。工厂中包含此工厂方法，此工厂不知道具体创建了哪个对象，只知道对象可以做哪些或者说要做哪些动作。比如：

```java
public abstract class PizzaStore {
	public Pizza orderPizza(String type) {
		Pizza pizza;
		pizza = createPizza(type);// 调用工厂方法
		
		pizza.prepare();
		pizza.bake();
		pizza.cut();
        pizza.box();
		
		return pizza;
	}
	
	//实例化对方的责任移到此“方法”中，其就如一个“工厂”
	protected abstract Pizza createPizza(String type);
}
```

光有上面的还不够，还需要将“工厂”生产出来的“产品”接口化。

比如：

```java
public abstract class Pizza {
	String name;
	Dough dough;
	Sauce sauce;
	Veggies veggies[];//原料
	...
	
	abstract void prepare();//在这个方法中，需要收集比萨所需的原料，而这些原料当然是来自原料工厂
	
	void bake() {
	...
	}
	
	void cut() {
	...
	}
	
	...
}
```

抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

要面向接口编程，要依赖倒置（Dependency Inversion Principle)。

Pizza要抽象，制作Pizza的原料要来自工厂（抽象），搞这么多抽象，只是为了解耦，让高层对象不要直接依赖于底层对象，而是通过依赖接口的方式，将两者之间的依赖关系解耦。这就是所谓的依赖倒置原则。

## 装饰者模式

给爱用继承的人一个全新的设计眼界……

定义：动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案。

举个例子：

“煎饼”的cost() {5元}；

“火腿肠”的cost() {2};

“火腿肠煎饼”的cost() { “煎饼”.cost() + “火腿肠”.cost() }；

“鸡肉煎饼”的cost() { “火腿肠煎饼”.cost() + “鸡肉”.cost() + 1元加工费 } 。

这样一层层的包装，装饰者将被装饰者包含在自己之中，被在被装饰者的行为之前或之后，加上自己的行为，以达到自己的目的。所得到的新行为，并不是继承自超类，而是有组合对象得来的。新行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。

装饰者和被装饰者对象有相同的超类型。这是为了达到“类型匹配”，而不是利用继承获得“行为”。

可以用一个或多个装饰者包装一个对象。

## 适配器模式与外观模式

对第三方的库，再封装一下，是不是也是应用了适配器模式呢？

**适配器模式**：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

经典的例子：

Iterator迭代器，此为interface，其中有hasNext() / next() / remove() 定义。

对于调用者来不需要看具体的对象是什么类型，比如String，或是Array，直接可以调用Iterator中方法，获取下一个元素之类的功能。

**外观模式**：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

外观不只是简化了接口路，也将客户从组件的子系统中解耦。

外观和适配器可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同接口。

## 迭代器与组合模式

**迭代器模式**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

**组合模式**：允许将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

## 状态模式

通过改变对象内部的状态来帮助对象控制自己的行为。

策略模式与状态模式是双胞胎，在出生时才分开。策略模式是围绕可以互换的算法来创建成功业务的。

## 生成器模式

封装一个产品的构造过程，并允许按步骤构造。

比如，UIlabel对象的生成，可以按步骤设置字体、颜色、背景、行数等，最终可以实例化一个特定的“产品”。

## 责任链

当你想让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式。

比如：点击事件传递机制。

## 蝇量

如想让某个类的一个实例能用来提供许多“虚拟”实例，就使用蝇量模式（Flyweight Pattern）。

优点：减少运行时对象实例的个数，节省内存。将许多“虚拟”对象的状态集中管理。

缺点：一旦实现了它，那单个的逻辑实例将无法拥有独立而不同的状态。

通俗的理解就是：用数组来存储“虚拟”的对象，这些“虚拟”的对象是可以通过计算来得到相应的状态的。


