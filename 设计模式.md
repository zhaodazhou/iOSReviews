# 设计模式

## 命令模式

目标是将“请求”的调用者与请求的执行者解耦。

具体是：将“请求”封装成对象，以便使用不同的请求来参数化其他对象。然后调用对象实现的接口execute()方法，方法中的“请求对象”再去执行相应的具体实现。

例如：

iOS上的addTarget方法。将用户点按button的这个动作请求，传递给参数对象target，让其selector来执行。而用户根本不需要知道这个target是谁，以及其是如何执行的。

再例如：

客户在餐厅点餐，只需要报出菜名后，由服务员把菜单交给后厨，后厨自动会根据菜名来做，做完后直接端给客户。这其中就是把请求者（客户）的请求（菜），传达给请求的执行者（后厨）来实现的。



## 模板方法模式

对算法进行封装。

在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中去实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

比如画K线，大部分股票类型都有共同的部分，但A股与美股，或者债券类的走势可能有些差异，这就可以通过这个模式来实现，毕竟总体的画法是步骤是一样的，就在于一些细节方面如何处理，这一点完全可以交给子类去实现。其中还可以通过钩子的挂载与否，改变这个算法的步骤。

```
func drawKLine() {
	drawXLine() // 画X轴
	drawAxis() // 画坐标
 	drawK() // 画K线

...
}


func drawAxis() {

}
```

又比如，冲咖啡与泡茶，都需要烧水、放茶叶（咖啡）、倒水、加糖（奶）等步骤，这四个步骤就可以理解为一个算法，可以抽象成一个模板方法模式。



## 工厂模式

简单工厂，通过静态方法实现多种类型对象的初始化。这样将创建的动作统一到一个方法中，便于维护，虽然简单，但实用。



简单工厂是由一个具体类或对象负责所有具体类的实例化，而工厂方法模式将类的实例化下放到子类中。工厂中包含此工厂方法，此工厂不知道具体创建了哪个对象，只知道对象可以做哪些或者说要做哪些动作。比如：

```
public abstract class PizzaStore {
	public Pizza orderPizza(String type) {
		Pizza pizza;
		pizza = createPizza(type);// 调用工厂方法
		
		pizza.prepare();
		pizza.bake();
		pizza.cut();
		pizza.box();
		
		return pizza;
	}
	
	//实例化对方的责任移到此“方法”中，其就如一个“工厂”
	protected abstract Pizza createPizza(String type);
}
```

光有上面的还不够，还需要将“工厂”生产出来的“产品”接口化。

比如：

```
public abstract class Pizza {
	String name;
	Dough dough;
	Sauce sauce;
	Veggies veggies[];//原料
	...
	
	abstract void prepare();//在这个方法中，需要收集比萨所需的原料，而这些原料当然是来自原料工厂
	
	void bake() {
	...
	}
	
	void cut() {
	...
	}
	
	...
}
```



抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

要面向接口编程，要依赖倒置（Dependency Inversion Principle)。

Pizza要抽象，制作Pizza的原料要来自工厂（抽象），搞这么多抽象，只是为了解耦，让高层对象不要直接依赖于底层对象，而是通过依赖接口的方式，将两者之间的依赖关系解耦。这就是所谓的依赖倒置原则。